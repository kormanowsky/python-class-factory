import inspect, adapters


def type_str(value):
    if inspect.isclass(value):
        return "class"
    if callable(value):
        return "function"
    return type(value).__name__


class AdapterManager:

    def __init__(self):
        self.adapters = {
            "str": adapters.StrAdapter(),
            "function": adapters.FunctionAdapter(),
        }

    def add_adapter(self, value_type, adapter):
        self.adapters[value_type] = adapter

    def get_appropriate_adapter(self, value):
        t = type_str(value)
        adapter = adapters.BaseAdapter()
        if t in self.adapters:
            adapter = self.adapters[t]
        return adapter


class Entity:

    def __init__(self, entity_class, name, source):
        if entity_class not in [Class, Method, Property]:
            raise ValueError("Entity class must be either "
                             "Class, Method or Property")
        if not self.check_name(name):
            raise ValueError("Entity name is not valid.")
        self.name = str(name)
        if not entity_class.check_source(source):
            raise ValueError("Entity source is not valid.")
        self.source = source
        self.adapter = AdapterManager().get_appropriate_adapter(source)

    def check_name(self, name):
        raise NotImplementedError()

    def get_code(self):
        raise NotImplementedError()


class EmptyClass:
    pass


class Class(Entity):

    def __init__(self, name, source=EmptyClass):
        super(Class, self).__init__(Class, name, source)
        self.classes = []
        self.methods = []
        self.properties = []
        if not isinstance(source, EmptyClass):
            for t in [Class, Method, Property]:
                members = inspect.getmembers(source, t.check_source)
                for member in members:
                    name, source = member
                    self.add_member(t, name, source)

    def check_name(self, name):
        # Todo
        return True

    @classmethod
    def check_source(cls, source):
        return type_str(source) == "class"

    def add_member(self, member_class, name, source):
        # Do not add __MEMBER__ members and mro method
        if name[:2] == "__" or name == "mro":
            return
        obj = member_class(name, source)
        if member_class == Class:
            self.classes.append(obj)
        elif member_class == Method:
            self.methods.append(obj)
        elif member_class == Property:
            self.properties.append(obj)
        else:
            raise ValueError("Incorrect member_class for Class.add_member")

    def add_class(self, name, source):
        self.add_member(Class, name, source)

    def add_method(self, name, source):
        self.add_member(Method, name, source)

    def add_property(self, name, source):
        self.add_member(Property, name, source)

    def get_code(self):
        strings = [
            "# Class {} generated by ClassFactory v0.0.1".format(self.name),
            "class {}:".format(self.name),
        ]
        for c in self.classes:
            strings.append("")
            c_code = c.get_code()
            for c_string in c_code[:-1]:
                strings.append("    {}".format(c_string))
        if len(self.classes):
            strings.append("")

        for p in self.properties:
            strings.append("    {}".format(p.get_code()))
        if len(self.properties):
            strings.append("")

        for m in self.methods:
            # Do not add __MEMBER__ members
            print(self.name, m, m.name, m.__class__)
            if m.name[:2] == "__":
                continue
            strings.append("")
            for m_string in m.get_code():
                strings.append("    {}".format(m_string))
        if len(self.methods):
            strings.append("")

        if len(strings) == 2:
            strings.append("    pass")
            strings.append("")
        return strings


class Method(Entity):

    METHOD_NAME_PLACEHOLDER = "__name_placeholder__"

    def __init__(self, name, source):
        super(Method, self).__init__(Method, name, source)

    def check_name(self, name):
        # Todo
        return True

    @classmethod
    def check_source(cls, source):
        return type_str(source) == "function"

    def get_code(self):
        return self.adapter.adapt(self.source).replace(self.METHOD_NAME_PLACEHOLDER, self.name).split("\n")


class Property(Entity):

    def __init__(self, name, source):
        if callable(source):
            raise ValueError("Source for Property is callable. Use Method for that source instead.")

        super(Property, self).__init__(Property, name, source)

    def check_name(self, name):
        # Todo
        return True

    @classmethod
    def check_source(cls, source):
        return not type_str(source) in ["class", "function"]

    def get_code(self):
        return "{} = {}".format(self.name, self.adapter.adapt(self.source))


class Factory:

    FILE_PATH = "{}.py"
    """
    def produce(self, nameloc=None):
        file_name = Factory.FILE_PATH.format(self.name)
        with open(file_name, "w+") as produce_file:
            strings = [
                "# Generated by ClassFactory v0.0.1",
                "class {}:".format(self.name)
            ]
            for d in [self.properties, self.methods]:
                for key in d:
                    string = d[key]
                    for s in string.split("\n"):
                        strings.append("    {}".format(s))
            for string in strings:
                produce_file.write("{}\n".format(string))
        mod = __import__(self.name, fromlist=[self.name])
        generated_class = getattr(mod, self.name)
        if loc is None:
            return generated_class
        loc[self.name] = generated_class
        return loc
    """