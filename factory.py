import adapters


def type_str(value):
    if callable(value):
        return "function"
    return type(value).__name__


class Factory:

    FILE_PATH = "{}.py"

    adapters = {
        "str": adapters.StrAdapter(),
        "function": adapters.FunctionAdapter(),
    }

    # Sets new class name
    def __init__(self, name):
        # todo Name checks
        self.name = str(name)
        self.properties = {}
        self.methods = {}
        self.classes = {}

    def add_member(self, name, value):
        t = type_str(value)
        adapter = adapters.BaseAdapter()
        if t in Factory.adapters:
            adapter = Factory.adapters[t]
        adapted = adapter.adapt(name, value)
        if adapter.__class__ == adapters.FunctionAdapter:
            self.methods[name] = adapted
        else:
            self.properties[name] = adapted

    def add_members(self, **kwargs):
        for name in kwargs:
            self.add_member(name, kwargs[name])

    def produce(self, loc=None):
        file_name = Factory.FILE_PATH.format(self.name)
        with open(file_name, "w+") as produce_file:
            strings = [
                "# Generated by ClassFactory v0.0.1",
                "class {}:".format(self.name)
            ]
            for d in [self.properties, self.methods]:
                for key in d:
                    string = d[key]
                    for s in string.split("\n"):
                        strings.append("    {}".format(s))
            for string in strings:
                produce_file.write("{}\n".format(string))
        mod = __import__(self.name, fromlist=[self.name])
        generated_class = getattr(mod, self.name)
        if loc is None:
            return generated_class
        loc[self.name] = generated_class
        return loc

