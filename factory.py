import adapters


def type_str(value):
    if callable(value):
        return "function"
    return type(value).__name__


class Entity:

    ENTITY_CLASS = 0
    ENTITY_METHOD = 1
    ENTITY_PROPERTY = 2

    def __init__(self, entity_type, name, source):
        entity_type = int(entity_type)
        if entity_type < self.ENTITY_CLASS or entity_type > self.ENTITY_PROPERTY:
            raise ValueError("entity type must be either "
                             "Entity.ENTITY_CLASS, Entity.ENTITY_METHOD or Entity.ENTITY_PROPERTY")
        self.type = entity_type
        # TODO Name check
        self.name = str(name)
        self.source = source

    def get_code(self):
        raise NotImplementedError()


class Class(Entity):

    def __init__(self, name, source):
        super(Class, self).__init__(super().ENTITY_CLASS, name, source)

    def get_code(self):
        return ""


class Method(Entity):

    def __init__(self, name, source):
        super(Method, self).__init__(super().ENTITY_METHOD, name, source)

    def get_code(self):
        return ""


class Property(Entity):

    def __init__(self, name, source):
        super(Property, self).__init__(super().ENTITY_PROPERTY, name, source)

    def get_code(self):
        return ""


class Factory:



    FILE_PATH = "{}.py"

    adapters = {
        "str": adapters.StrAdapter(),
        "function": adapters.FunctionAdapter(),
    }

    # Sets new class name
    def __init__(self, name):
        # todo Name checks
        self.name = str(name)
        self.properties = {}
        self.methods = {}
        self.classes = {}

    def add_member(self, name, value):
        t = type_str(value)
        adapter = adapters.BaseAdapter()
        if t in Factory.adapters:
            adapter = Factory.adapters[t]
        adapted = adapter.adapt(name, value)
        if adapter.__class__ == adapters.FunctionAdapter:
            self.methods[name] = adapted
        else:
            self.properties[name] = adapted

    def add_members(self, **kwargs):
        for name in kwargs:
            self.add_member(name, kwargs[name])

    def produce(self, loc=None):
        file_name = Factory.FILE_PATH.format(self.name)
        with open(file_name, "w+") as produce_file:
            strings = [
                "# Generated by ClassFactory v0.0.1",
                "class {}:".format(self.name)
            ]
            for d in [self.properties, self.methods]:
                for key in d:
                    string = d[key]
                    for s in string.split("\n"):
                        strings.append("    {}".format(s))
            for string in strings:
                produce_file.write("{}\n".format(string))
        mod = __import__(self.name, fromlist=[self.name])
        generated_class = getattr(mod, self.name)
        if loc is None:
            return generated_class
        loc[self.name] = generated_class
        return loc

