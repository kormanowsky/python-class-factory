import inspect
import os
from threading import Timer


def type_str(value):
    if callable(value):
        return "function"
    return type(value).__name__


class Factory:

    FILE_PATH = "{}.py"

    #class_adapters = {
     #   "str": StrAdapter,
    #    "int": IntAdapter,
    #    "boolean": BooleanAdapter,
    #    "none": NoneAdapter,
    #    ""
    #}

    # Sets new class name
    def __init__(self, name):
        # todo Name checks
        self.name = str(name)
        self.properties = {}
        self.methods = {}
        self.classes = {}

    def add_property(self, name, value):


    @classmethod
    def produce(cls, name, **kwargs):
        file_name = cls.FILE_PATH.format(name)
        with open(file_name, "w+") as producefile:
            strings = [
                "# Generated by Classproduceer v0.0.1",
                "class {}:".format(name)
            ]

            for key in kwargs:
                value = kwargs[key]
                t = type(value)
                if callable(t):
                    value_lines = inspect.getsourcelines(value)[0]
                    for line_num, line in enumerate(value_lines):
                        if line_num == 0:
                            line = line.replace(line.split(" ")[1].split("(")[0], key)
                        line = "    " + line.replace("\n", "")
                        value_lines[line_num] = line
                    strings.append("")
                    strings += value_lines
                elif t == "str":
                    # todo
                    continue
                else:
                    strings.append("    {} = {}".format(key, value))

            for string in strings:
                producefile.write(string + "\n")

        mod = __import__(name, fromlist=[name])
        generated_class = getattr(mod, name)
        #Timer(1, os.remove, [file_name]).start()
        return generated_class


