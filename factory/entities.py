from factory.adapters import AdapterManager
from factory.functions import *


class Empty:
    pass


class Entity:

    def __init__(self, entity_class, name, source):
        if entity_class not in [Class, Method, Property]:
            raise ValueError("Entity class must be either "
                             "Class, Method or Property")
        if not self.check_name(name):
            raise ValueError("Entity name is not valid.")
        self.name = str(name)
        if not entity_class.check_source(source):
            raise ValueError("Entity source is not valid.")
        self.source = source
        self.adapter = AdapterManager().get_appropriate_adapter(source)

    def check_name(self, name):
        raise NotImplementedError()

    def get_code(self):
        raise NotImplementedError()


class Class(Entity):

    def __init__(self, name, source):
        super(Class, self).__init__(Class, name, source)
        self.classes = []
        self.methods = []
        self.properties = []
        if source != Empty:
            for t in [Class, Method, Property]:
                members = inspect.getmembers(source, t.check_source)
                for member in members:
                    mem_name, mem_source = member
                    self.add_member(t, mem_name, mem_source)

    def check_name(self, name):
        # Todo
        return True

    @classmethod
    def check_source(cls, source):
        return type_str(source) == "class"

    def add_member(self, member_class, name, source):
        # Do not add __MEMBER__ methods and mro method
        if name[:2] == "__" or name == "mro":
            return
        obj = member_class(name, source)
        if member_class == Class:
            self.classes.append(obj)
        elif member_class == Method:
            self.methods.append(obj)
        elif member_class == Property:
            self.properties.append(obj)
        else:
            raise ValueError("Incorrect member_class for Class.add_member")

    def add_class(self, name, source):
        self.add_member(Class, name, source)

    def add_method(self, name, source):
        self.add_member(Method, name, source)

    def add_property(self, name, source):
        self.add_member(Property, name, source)

    def get_code(self):
        strings = [
            "# Class {} generated by ClassFactory v0.0.1".format(self.name),
            "class {}:".format(self.name),
        ]
        for c in self.classes:
            strings.append("")
            c_code = c.get_code()
            for c_string in c_code[:-1]:
                strings.append("    {}".format(c_string))
        if len(self.classes):
            strings.append("")

        for p in self.properties:
            strings.append("    {}".format(p.get_code()))
        if len(self.properties):
            strings.append("")

        for m in self.methods:
            strings.append("")
            for m_string in m.get_code():
                strings.append("    {}".format(m_string))
        if len(self.methods):
            strings.append("")

        if len(strings) == 2:
            strings.append("    pass")
            strings.append("")
        return strings


class Method(Entity):

    METHOD_NAME_PLACEHOLDER = "__name_placeholder__"

    def __init__(self, name, source):
        super(Method, self).__init__(Method, name, source)

    def check_name(self, name):
        # Todo
        return True

    @classmethod
    def check_source(cls, source):
        return type_str(source) == "function"

    def get_code(self):
        return self.adapter.adapt(self.source).replace(self.METHOD_NAME_PLACEHOLDER, self.name).split("\n")


class Property(Entity):

    def __init__(self, name, source):
        if callable(source):
            raise ValueError("Source for Property is callable. Use Method for that source instead.")

        super(Property, self).__init__(Property, name, source)

    def check_name(self, name):
        # Todo
        return True

    @classmethod
    def check_source(cls, source):
        return not type_str(source) in ["class", "function"]

    def get_code(self):
        return "{} = {}".format(self.name, self.adapter.adapt(self.source))